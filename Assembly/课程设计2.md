# 课程设计2

本次课程设计的任务是编写一个可以自行启动的计算机，不需要在现有的操作系统环境中运行的程序。我所想实现的是任务程序可以在开机后自动执行，主要是避免保护模式下的一些意想不到的错误。

该程序功能如下：

1. 列出功能选项，让用户通过键盘进行选择，界面如下：

   1. reset  pc ;重新启动计算机
   2. start  system;引导现有的操作系统
   3. clock  ;进入时钟程序
   4. set  clock;设置时间

2. 用户输入'1'后，重新启动计算机(考虑ffff:0单元)

3. 用户输入'2'后，引导现有的操作系统(考虑硬盘C的0道0面1扇区)

4. 用户输入'3'后，执行动态显示当前日期、时间的程序

   格式：年/月/日 时/分/秒,进入此选项后，一直动态显示当前时间，在屏幕上将出现按秒变化的效果(循环读取CMOS)，按下F1键后，改变显示颜色；按下ESC键，返回到主菜单(利用键盘中断)

5. 用户输入‘4’后，可更改当前的时间、日期，更改后按ESC键返回主菜单（输入字符串）

> 1. 关键点
>
>    由于需要自动执行任务程序，故需要将系统程序及安装程序装在内存中，问题来了，由于程序的长度大于512B，从而需要用多个扇区存放，这种情况下，处于软盘0道0面1扇区中的程序就必须负责将其他扇区中的内容读入内存
>
>    ```assembly
>    ;读取kernel到7c00h上
>    load:
>    		mov ax,0
>    		mov	ds,ax 
>    		mov ss,ax
>    		mov sp,7c00h
>    		
>    		;设置rd_kern的参数
>    		;设置es:bx参数
>    		mov	ax,7e00h
>    		mov es,ax
>    		mov bx,0	;es:bx=7c00:0
>    		
>    		mov si,1
>    		mov cx,1400
>    		
>    		;读取700KB的kernel到7e00上
>    		call rd_kern
>    
>    
>    
>    ;函数名:rd_kern
>    ;功能:读取软驱A上连续多个扇区
>    ;参数
>    	;1.	es:bx 读取数据存放的目的地址
>    	;2.	si		指定起始逻辑扇区号
>    	;3. cx		欲读取的扇区数目
>    
>    rd_kern:
>    			push	ax
>    	rd_k1:
>    			call	rd_sect
>    			mov 	ax,es
>    			add 	ax,20h
>    			mov		es,ax	;es:bx +=512
>    			inc 	si
>    			loop 	rd_k1
>    			pop 	ax
>    			ret
>    ```
>
> 2. 由于接下来的程序用nasm编译，故需学习其基本语法。暂未检查其正确性
>
>    ```assembly
>    ;本程序主要分为3个部分
>    ;1.把程序复制到软盘
>    ;2.把软盘从第二个扇区开始读入内存
>    ;3.系统程序,实现本课程设计的4个要求
>    
>    code segment
>    assume cs:code			
>    	start:										;把install1复制到软盘的第一个扇区
>    				mov ax,install1
>    				mov es,ax
>    				mov bx,0
>    				mov ah,3
>    				mov al,1
>    				mov ch,0
>    				mov cl,1
>    				mov dh,0
>    				mov dl,0
>    				int 13h
>    				
>    										;从第二个扇区开始,把install2全部复制到软盘
>    				mov ax,install2
>    				mov es,ax
>    				mov bx,0
>    				mov ah,3
>    				mov al,15
>    				mov cl,2
>    				int 13h
>    				
>    				mov ax,4c00h
>    				int 21h
>    code ends
>    
>    intall1 segment						;负责把主程序从软盘的第二个扇区开始全部读入内存
>    				assume cs:install1
>    				mov ax,2000h
>    				mov es,ax
>    				mov ah,2
>    				mov al,15
>    				mov ch,0
>    				mov cl,2
>    				mov dh,0
>    				mov bx,0
>    				int 13h
>    				
>    				mov ax,2000h
>    				push ax
>    				mov ax,0
>    				push ax
>    				retf 					;pop ip,pop cs,(IP)=0,(CS)=2000h
>    				
>    install1 ends
>    
>    org 2000h								;由于定义了table数据标号
>    install2 segment
>    assume cs:install2
>    										;主程序实现4个小功能
>    		ready:	jmp short main
>    		
>    		table dw resetpc,startos,clock,setclock
>    		
>    		main:	
>    				call manu
>    				call rdkb0
>    				cmp ah,02
>    				jb main
>    				cmp ah,05
>    				ja main
>    				mov al,ah
>    				mov ah,0
>    				sub al,2
>    				add al,al
>    				mov bx,ax
>    				call word ptr table[bx]
>    				jmp short main
>    				
>    		rdkb0:	mov ah,0				;读取键盘一个输入,同时清除缓冲区
>    				int 16h					;注意此时,键盘没有输入则会等待输入
>    				ret
>    				
>    		rdkb1:	mov ah,1				;读取键盘一个输入,不清除缓冲区
>    				int 16h					;此时不等待键盘输入
>    				ret	
>    		
>    resetpc:		call clear				;重启计算机
>    				mov ax,0ffffh
>    				push ax
>    				mov ax,0
>    				push ax
>    				retf					;(IP)=0,(CS)=0ffffh
>    		
>    startos:		call clear				;引导操作系统
>    				mov ax,0
>    				mov es,ax
>    				mov bx,7c00h
>    				
>    				mov al,1
>    				mov ch,0
>    				mov cl,1
>    				mov dh,0
>    				mov dl,80h
>    				mov ah,2
>    				int 13h
>    				
>    				mov ax,0
>    				push ax
>    				mov ax,7c00h
>    				push ax
>    				retf					;(IP)=7c00h,(CS)=0
>    				
>    clock:		jmp short showclock
>    										;显示时钟
>    			s: db	9,8,7,4,2,0			;年 月 日 时 分 秒
>    			s1:db	47,47,32,58,58,0	;单独显示符号的ASCII码
>    
>    	 showclock:	
>    				push ds
>    				push es
>    				push si
>    				push di
>    				push bp
>    				push ax
>    				push bx
>    				push cx
>    				push dx
>    				
>    			
>    				
>    				call clear
>    				mov dl,2
>    				mov ax,cs
>    				mov ds,ax
>    				mov bp,offset s
>    				mov di,offset s1
>    				mov si,64
>    				
>    				push cx
>    				mov al,ds:[bp]
>    				out 70h,al
>    				in al,71h
>    				mov ah,al
>    				mov cl,4
>    				shr ah,cl
>    				and al,00001111b		;转成两位十进制数
>    				
>    				add ah,30h
>    				add al,30h
>    				
>    				mov bx,0b800h
>    				mov es,bx
>    				mov byte ptr es:[160*12+si],ah	;显示年 月 日 时 分 秒的十位数码
>    				mov byte ptr es:[160*12+si+2],al;显示年 月 日 时 分 秒的个位数码
>    				mov al,ds:[di]					
>    				mov byte ptr es:[160*12+si+4],al;显示单独字符
>    				
>    				pop cx
>    				inc bp
>    				inc di
>    				add si,6
>    				loop change
>    
>    
>    				pop dx
>    				pop cx
>    				pop bx
>    				pop ax
>    				pop bp
>    				pop di
>    				pop si
>    				pop es
>    				pop ds
>    				ret
>    		
>    setclock:	jmp near ptr clkconf	;设置时钟
>    			instruction:
>    				db '             Warning!             ',0
>    				db 'Please strictly follow the example',0
>    				db '      yy/mm/dd hh:mm:ss           ',0               
>    	clocktemp:	db 20 dup(0)
>    	  setaddr:	db 9,8,7,4,2,0
>    	  clkconf:	push ds
>    				push es
>    				push si
>    				push di
>    				push bp
>    				push ax
>    				push bx
>    				push cx
>    				push dx
>    				call clear
>    				push cs
>    				pop ds
>    				
>    				mov ax,0b800h
>    				mov es,ax
>    				mov di,10*160+20*2
>    				mov bx,offset instruction
>    				
>    				mov cx,3
>    		strs3:	push cx
>    				mov bp,0
>    		strs2:	mov cl,[bx]
>    				mov ch,0
>    				jcxz strs1
>    				mov es:[di+bp],cl
>    				mov byte ptr es:[di+bp+1],4
>    				inc bx
>    				add bp,2
>    				jmp short strs2
>    		strs1:	pop cx
>    				inc bx
>    				add si,160
>    				loop strs3
>    				
>    				mov si,offset clocktemp 
>    				mov dh,13
>    				mov dl,26
>    				call getstr
>    				
>    				mov bx,offset clocktemp 
>    				mov bp,offset setaddr
>    				
>    				mov cx,6
>    		strs4:	push cx
>    				mov ch,0
>    				mov cl,4
>    				mov ah,[bx]
>    				mov al,[bx+1]
>    				sub ah,30h
>    				sub al,30h
>    				shl	ah,cl
>    				add ah,al
>    				mov al,ds:[bp]
>    				out 70h,al
>    				mov al,ah
>    				out 71h,al
>    				pop cx
>    				add bx,3
>    				inc bp
>    				loop strs4
>    		rdagain:call rdkb0
>    				cmp al,1bh
>    				jne rdagain
>    				call clear
>    				pop dx
>    				pop cx
>    				pop bx
>    				pop ax
>    				pop bp
>    				pop di
>    				pop si
>    				pop es
>    				pop ds
>    				ret
>    				
>    				
>    getstr:			push ax
>    			
>    		getstrs:mov ah,0
>    				int 16h
>    				cmp al,20h
>    				jb nochar						;ASCII码小于20h,说明不是字符
>    				mov ah,0
>    				call charstack					;字符入栈
>    				mov ah,2
>    				call charstack					;显示栈中的字符
>    				jmp getstrs
>    				
>    	nochar:		cmp ah,0eh						;退格键的扫描码
>    				je	backspace
>    				cmp ah,1ch						;Enter键的扫描码
>    				je enter
>    				jmp getstrs
>    				
>    	backspace:	mov ah,1
>    				call charstack					;字符出栈
>    				mov ah,2
>    				call charstack					;显示栈中的字符
>    				jmp getstrs
>    				
>    	enter:		mov al,0
>    				mov ah,0
>    				call charstack					;0入栈
>    				mov ah,2
>    				call charstack					;显示栈中的字符
>    				pop ax
>    				ret
>    				
>    	;名称:字符栈的入栈,出栈和显示
>    	;参数说明:	(ah)=功能号,0表示入栈,1表示出栈,2表示显示;ds:si指向字符栈空间
>    	;对于0号功能:(al)=入栈字符
>    	;对于1号功能:(al)=返回的字符
>    	;对于2号功能:(dh),(dl)=字符串在屏幕上显示的行,列位置
>    
>    	charstack:	jmp short charstart
>    
>    	table		dw charpush,charpop,charshow
>    	top 		dw 0							;栈顶
>    
>    	charstart:	push bx
>    				push dx
>    				push di
>    				push es
>    				
>    				cmp ah,2
>    				ja sret
>    				mov bl,ah
>    				mov bh,0
>    				add bx,bx
>    				jmp word ptr table[bx]
>    				
>    	charpush:	mov bx,top 
>    				mov [si][bx],al
>    				inc top
>    				jmp sret
>    				
>    	charpop:	cmp top,0
>    				je sret
>    				dec top
>    				mov bx,top
>    				mov al,[si][bx]
>    				jmp sret
>    				
>    	charshow:	mov bx,0b800h
>    				mov es,bx
>    				mov al,160
>    				mov ah,0
>    				mul dh
>    				mov di,ax
>    				add dl,dl
>    				mov dh,0
>    				add di,dx						;es:di指向显存地址
>    				
>    				mov bx,0
>    	  charshows:cmp bx,top
>    				jne noempty
>    				mov byte ptr es:[di],' '
>    				jmp sret
>    		noempty:mov al,[si][bx]
>    				mov es:[di],al
>    				mov byte ptr es:[di+2],' '
>    				inc bx
>    				add di,2
>    				jmp charshows
>    		
>    	   sret:	pop es
>    				pop si
>    				pop dx
>    				pop bx
>    				ret
>    				
>    
>    manu:	jmp short show 
>    				db '1) reset pc',0
>    				db '2) start system',0
>    				db '3) clock',0
>    				db '4) set clock',0
>    		
>    		show:	push ds
>    				push es
>    				push si
>    				push di
>    				push ax
>    				push bx
>    				push cx
>    				
>    				puch cs
>    				pop ds
>    				mov si,offset manu
>    				add si,2
>    				mov ax,0b800h
>    				mov es,ax
>    				mov bx,12*160+25*2
>    				
>    				mov cx,4
>    			s3: push cx
>    				mov di,0
>    			s1:	mov cl,[si]
>    				mov ch,0
>    				jcxz s2
>    				mov es:[bx+di],cl
>    				mov byte ptr es:[bx+di+1],2
>    				inc si
>    				add si,2
>    				jmp short s1
>    			s2:	pop cx
>    				inc si
>    				add bx,160
>    				loop s3
>    				
>    				pop cx
>    				pop bx
>    				pop ax
>    				pop di
>    				pop si
>    				pop es
>    				pop ds
>    				ret
>    				
>    	clear:		push bx
>    				push cx
>    				push es
>    				
>    				mov bx,0b800h
>    				mov es,bx
>    				mov bx,0
>    				mov cx,2000
>    		clears1:mov byte ptr es:[bx],' '
>    				add bx,2
>    				loop clears1
>    				
>    				mov cx,2000
>                    mov bx,1
>        clears2:    mov byte ptr es:[bx],07
>                    add bx,2
>                    loop clears2
>    				
>    				pop es
>    				pop cx
>    				pop bx
>    				ret
>    
>    install2 ends
>    
>    end start
>    ```

寒假深入学习